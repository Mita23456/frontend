
schema {
	query: Query
	mutation: Mutation
}
scalar Time
type Query {
	viewer: User
  
	# Fetches an object given its ID
	node(
	  # The ID of an object
	  id: ID!
	): Node
	feeds(first: Int, last: Int, after: String, before: String): StoriesConnection!
}

interface Node {
	id: ID!
}

type PageInfo {
	startCursor: String
	endCursor: String
	hasNextPage: Boolean!
	hasPreviousPage: Boolean!
}

type Badge implements Node {
	currentLevel: Int!
	displayName: String!
	id: ID!
	points: Int!
	progressPercentageToNextLevel: Int!
	timeCreated: Time!
	timeUpdated: Time!
} 

type BadgesConnection {
	edges: [BadgeEdge]!
	pageInfo: PageInfo!
} 

type BadgeEdge {
	node: Badge!
	cursor: String!
}

type Comment implements Node {
	abstractContent: String!
	contentJson: String!
	createdBy: User!
	id: ID!
	reactions(first: Int, last: Int, after: String, before: String): ReactionsConnection!
	timeCreated: Time!
	timeUpdated: Time!
}

input CommentInput {
	abstractContent: String!
	contentJson: String!
	storyID: ID!
}
input UpdateCommentInput {
	id: ID!
} 

type CommentsConnection {
	edges: [CommentEdge]!
	pageInfo: PageInfo!
} 

type CommentEdge {
	node: Comment!
	cursor: String!
}

type GitContributionStats {
	issues: Int!
	pullRequests: Int!
}

input GitContributionStatsInput {
	issues: Int!
	pullRequests: Int!
}

type Issue implements Node {
	body: String!
	commentCount: Int!
	id: ID!
	issueType: String!
	labels: [String]!
	repository: String!
	repositoryAvatar: String!
	repositoryUpdatedAt: Time!
	title: String!
	url: String!
} 

type IssuesConnection {
	edges: [IssueEdge]!
	pageInfo: PageInfo!
} 

type IssueEdge {
	node: Issue!
	cursor: String!
}

type Reaction implements Node {
	createdBy: User!
	id: ID!
	timeCreated: Time!
	timeUpdated: Time!
}

input ReactionInput {
	commentID: ID!
	storyID: ID!
}
input UpdateReactionInput {
	id: ID!
} 

type ReactionsConnection {
	edges: [ReactionEdge]!
	pageInfo: PageInfo!
} 

type ReactionEdge {
	node: Reaction!
	cursor: String!
}

type Reputation {
	value: Float!
}

input ReputationInput {
	value: Float!
}

type Story implements Node {
	abstractContent: String!
	comments(first: Int, last: Int, after: String, before: String): CommentsConnection!
	contentJson: String!
	createdBy: User!
	id: ID!
	reactions(first: Int, last: Int, after: String, before: String): ReactionsConnection!
	thumbnail: String!
	timeCreated: Time!
	timeUpdated: Time!
	title: String!
	urlSuffix: String!
}

input StoryInput {
	abstractContent: String!
	contentJson: String!
	thumbnail: String!
	title: String!
	urlSuffix: String!
}
input UpdateStoryInput {
	id: ID!
} 

type StoriesConnection {
	edges: [StoryEdge]!
	pageInfo: PageInfo!
} 

type StoryEdge {
	node: Story!
	cursor: String!
}

type User implements Node {
	avatar: String!
	badges(first: Int, last: Int, after: String, before: String): BadgesConnection!
	bio: String!
	gitContributionStats: GitContributionStats!
	handle: String!
	id: ID!
	issuesFromLastRepo(first: Int, last: Int, after: String, before: String): IssuesConnection!
	issuesFromOtherRecentRepos(first: Int, last: Int, after: String, before: String): IssuesConnection!
	name: String!
	relevantIssues(first: Int, last: Int, after: String, before: String): IssuesConnection!
	reputation: Reputation!
	stories(first: Int, last: Int, after: String, before: String): StoriesConnection!
	timeCreated: Time!
	timeUpdated: Time!
}

input UserInput {
	avatar: String!
	bio: String! 
	gitContributionStats: GitContributionStatsInput!
	handle: String!
	name: String! 
	reputation: ReputationInput!
}
input UpdateUserInput {
	id: ID!
	avatar: String
	bio: String 
	gitContributionStats: GitContributionStatsInput
	name: String 
	reputation: ReputationInput
}

type Mutation { 
	createComment(comment:CommentInput!): Comment! 
	updateComment(comment: UpdateCommentInput!): Comment! 
	createReaction(reaction:ReactionInput!): Reaction! 
	updateReaction(reaction: UpdateReactionInput!): Reaction! 
	createStory(story:StoryInput!): Story! 
	updateStory(story: UpdateStoryInput!): Story! 
	createUser(user:UserInput!): User! 
	updateUser(user: UpdateUserInput!): User!
}
